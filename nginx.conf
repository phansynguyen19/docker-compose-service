
user  nginx;
worker_processes  1;

error_log  /var/log/nginx/error.log warn;
pid        /var/run/nginx.pid;

load_module modules/ngx_http_perl_module.so;
load_module modules/ngx_http_js_module.so;
load_module modules/ngx_http_headers_more_filter_module.so;

events {
    worker_connections  1024;
}

http {
    include       /etc/nginx/mime.types;
    default_type  application/octet-stream;

    log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '
                      '$status $body_bytes_sent "$http_referer" '
                      '"$http_user_agent" "$http_x_forwarded_for"';

    access_log  /var/log/nginx/access.log  main;

    sendfile        on;
    #tcp_nopush     on;

    keepalive_timeout  65;

    # ============================================================================
    # CORS Configuration - Dynamic origin validation
    # ============================================================================
    # This map validates incoming origins against allowed patterns.
    # It supports multiple frontend services on different ports.
    # To add new allowed origins, add them to the CORS_ALLOWED_ORIGINS env var
    # or add new regex patterns below.
    # ============================================================================
    map $http_origin $cors_origin {
        default "";
        # Allow any localhost with port (http://localhost:3000, http://localhost:8080, etc.)
        "~^http://localhost(:\d+)?$" $http_origin;
        # Allow any 127.0.0.1 with port
        "~^http://127\.0\.0\.1(:\d+)?$" $http_origin;
        # Allow https variants
        "~^https://localhost(:\d+)?$" $http_origin;
        "~^https://127\.0\.0\.1(:\d+)?$" $http_origin;
    }

    server {
        listen       80;
        server_name  revproxy-service;
        resolver 127.0.0.11;

        listen 443 ssl;

        ssl_certificate /etc/nginx/ssl/service.crt;
        ssl_certificate_key /etc/nginx/ssl/service.key;

        set $access_token "";
        set $csrf_check "ok-tokenauth";
        if ($cookie_access_token) {
            set $access_token "bearer $cookie_access_token";
            # cookie auth requires csrf check
            set $csrf_check "fail";
        }
        if ($http_authorization) {
            # Authorization header is present - prefer that token over cookie token
            set $access_token "$http_authorization";
        }

        proxy_set_header   Authorization "$access_token";

        proxy_buffer_size          16k;
        proxy_buffers              8 16k;
        proxy_busy_buffers_size    32k;

        large_client_header_buffers 4 8k;
        client_header_buffer_size 4k;

        #
        # CSRF check
        # This block requires a csrftoken for all POST requests.
        #
        if ($cookie_csrftoken = $http_x_csrf_token) {
          # this will fail further below if cookie_csrftoken is empty
          set $csrf_check "ok-$cookie_csrftoken";
        }
        if ($request_method != "POST") {
          set $csrf_check "ok-$request_method";
        }
        if ($cookie_access_token = "") {
          # do this again here b/c empty cookie_csrftoken == empty http_x_csrf_token - ugh
          set $csrf_check "ok-tokenauth";
        }

        location /user/ {
            proxy_pass http://fence-service/;
        }

        # Keycloak proxy - for browser access
        location /auth/ {
            proxy_pass http://keycloak:8080/;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
            proxy_buffer_size 128k;
            proxy_buffers 4 256k;
            proxy_busy_buffers_size 256k;
        }

        # OAuth2 endpoints with CORS support
        location ^~ /oauth2/ {
            # Hide CORS headers from backend to prevent duplicates
            proxy_hide_header 'Access-Control-Allow-Origin';
            proxy_hide_header 'Access-Control-Allow-Credentials';
            proxy_hide_header 'Access-Control-Allow-Methods';
            proxy_hide_header 'Access-Control-Allow-Headers';

            if ($request_method = 'OPTIONS') {
                add_header 'Access-Control-Allow-Origin' $http_origin always;
                add_header 'Access-Control-Allow-Methods' 'GET, POST, OPTIONS' always;
                add_header 'Access-Control-Allow-Headers' 'Authorization, Content-Type, X-CSRF-Token' always;
                add_header 'Access-Control-Allow-Credentials' 'true' always;
                add_header 'Access-Control-Max-Age' 3600 always;
                add_header 'Content-Type' 'text/plain; charset=utf-8' always;
                add_header 'Content-Length' 0 always;
                return 204;
            }

            add_header 'Access-Control-Allow-Origin' $http_origin always;
            add_header 'Access-Control-Allow-Credentials' 'true' always;

            proxy_pass http://fence-service/oauth2/;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        }

        location = /_status {
            default_type application/json;
            return 200 "{ \"message\": \"Feelin good!\" }\n";
        }

        # ========================================
        # Arborist Management Endpoints with CORS
        # ========================================
        # This single block handles ALL Arborist management endpoints:
        # /authz/role, /authz/group, /authz/policy, /authz/resource, /authz/user, /authz/client
        # and any future endpoints like /authz/permission, /authz/tag, etc.
        # No need to add new location blocks for new endpoints!
        
        location ~ ^/authz/(role|group|policy|resource|user|client|auth)(/.*)?$ {
            # Handle CORS preflight requests
            if ($request_method = 'OPTIONS') {
                add_header 'Access-Control-Allow-Origin' $http_origin always;
                add_header 'Access-Control-Allow-Methods' 'GET, POST, PUT, PATCH, DELETE, OPTIONS' always;
                add_header 'Access-Control-Allow-Headers' 'Authorization, Content-Type, X-CSRF-Token' always;
                add_header 'Access-Control-Allow-Credentials' 'true' always;
                add_header 'Access-Control-Max-Age' 3600 always;
                add_header 'Content-Type' 'text/plain; charset=utf-8' always;
                add_header 'Content-Length' 0 always;
                return 204;
            }

            # Add CORS headers for actual requests
            add_header 'Access-Control-Allow-Origin' $http_origin always;
            add_header 'Access-Control-Allow-Credentials' 'true' always;

            # Rewrite /authz/xxx to /xxx before proxying to Arborist
            # Example: /authz/role/admin -> /role/admin
            rewrite ^/authz/(.*)$ /$1 break;

            proxy_pass http://arborist-service;
            proxy_set_header Host $host;
            proxy_set_header Authorization "$access_token";
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        }

        #
        # authorization endpoint
        # https://hostname/authz?resource=programs/blah&method=acb&service=xyz
        #
        location ~ /authz/? {
            if ($csrf_check !~ ^ok-\S.+$) {
                return 403 "failed csrf check";
            }
            set $proxy_service  "arborist";

            proxy_pass http://arborist-service/auth/proxy?resource=$arg_resource&method=$arg_method&service=$arg_service;
        }

        location = /authz/resources {
            if ($csrf_check !~ ^ok-\S.+$) {
                return 403 "failed csrf check";
            }

            proxy_pass http://arborist-service/auth/resources;
        }

        location = /authz/mapping {
            if ($csrf_check !~ ^ok-\S.+$) {
                return 403 "failed csrf check";
            }

            # Do not expose POST /auth/mapping
            limit_except GET {
                deny all;
            }

            # Do not pass the username arg here! Otherwise anyone can see anyone's access.
            # Arborist will fall back to parsing the jwt for username.
            proxy_pass http://arborist-service/auth/mapping;
        }
    }
}
